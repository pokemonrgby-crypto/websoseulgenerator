<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>집필실 (V6)</title>
    <style>
        body { font-family: -apple-system, sans-serif; background: #f0f2f5; }
        .editor-layout {
            display: grid; grid-template-columns: 1fr 350px;
            gap: 20px; padding: 20px;
            max-width: 1600px; margin: 0 auto;
            height: calc(100vh - 40px);
        }
        .main-content {
            background: #fff; border-radius: 12px; padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); overflow-y: auto;
        }
        .sidebar {
            background: #fff; border-radius: 12px; padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); overflow-y: auto;
        }
        h2 { margin-top: 0; }
        button {
            background: #007aff; color: white; border: none;
            padding: 10px 15px; border-radius: 8px; cursor: pointer;
            margin-right: 5px; margin-bottom: 5px; width: 100%;
        }
        button:disabled { background: #999; }
        textarea { width: 100%; height: 100px; border-radius: 8px; border: 1px solid #ddd; }
        
        /* 블록 에디터 */
        #novel-blocks { min-height: 400px; }
        #novel-blocks p { padding: 4px 8px; border-radius: 4px; }
        #novel-blocks p:hover { background-color: #f0f8ff; }

        /* AI 기능 버튼 */
        button.main-ai { background: #28a745; font-weight: bold; padding: 12px; }
        button.sub-ai { background: #6c757d; font-size: 12px; padding: 8px; }
        
        /* 회차 내 DB (변경 전/후) */
        .episode-db {
            border: 1px dashed #aaa; padding: 10px; border-radius: 8px;
            background: #fafafa;
        }
    </style>
</head>
<body>
    <div class="editor-layout">
        <div class="main-content">
            <h2 id="episodeTitle">... (회차 제목)</h2>
            <div id="novel-blocks">
                <p>A가 사과를 주웠다.</p>
                <p>&nbsp;</p>
                <p>"음, 달콤한 향기가 나네?"</p>
                </div>
        </div>

        <div class="sidebar">
            <h2>AI 기능</h2>

            <fieldset style="border: 2px solid #28a745; border-radius: 8px; padding: 10px;">
                <legend>핵심 기능 (3단계)</legend>
                <textarea id="sceneRequest" placeholder="생성할 씬을 요청하세요.&#10;예: A가 B를 만나는 씬."></textarea>
                <button id="generateSceneButton" class="main-ai">✨ 씬 생성하기 (3단계)</button>
                <pre id="sceneResult" style="background: #f0f0f0; padding: 5px;"></pre>
            </fieldset>

            <hr style="margin: 20px 0;">

            <fieldset style="border: 1px solid #6c757d; border-radius: 8px; padding: 10px;">
                <legend>편의 기능 (Proxy)</legend>
                <textarea id="proxyPrompt" placeholder="일관성 확인 등 간단한 질문&#10;예: A의 말투는?"></textarea>
                <button id="proxyButton" class="sub-ai">Gemini-Flash로 질문 (Proxy)</button>
                <pre id="proxyResult" style="background: #f0f0f0; padding: 5px;"></pre>
            </fieldset>
            
            <hr style="margin: 20px 0;">

            <div class="episode-db">
                <h3>이 회차의 캐릭터 변경</h3>
                <label>변경 전 (참고용):</label>
                <textarea id="dbBefore" readonly>{"name": "A", "status": "팔 있음"}</textarea>
                <label>변경 후 (AI가 참고):</label>
                <textarea id="dbAfter">{"name": "A", "status": "팔 잃음"}</textarea>
                <button id="saveEpisodeDbButton" class="sub-ai">회차 DB 저장</button>
            </div>
        </div>
    </div>

    <script>
        const novelId = new URLSearchParams(window.location.search).get('id');
        const episodeNum = new URLSearchParams(window.location.search).get('ep');
        document.getElementById('episodeTitle').textContent = `${novelId} - ${episodeNum}화 집필 중`;

        const secretKey = localStorage.getItem('MY_SECRET_KEY'); // (인증 키)

        // --- [핵심 기능] 3단계 파이프라인 호출 ---
        const generateBtn = document.getElementById('generateSceneButton');
        const sceneResultEl = document.getElementById('sceneResult');
        
        generateBtn.addEventListener('click', async () => {
            const sceneRequest = document.getElementById('sceneRequest').value;
            // (이 회차의 DB(dbAfter)와 마스터 DB를 조합하여 전송)
            const worldviewDatabase = document.getElementById('dbAfter').value;
            
            if (!secretKey || !sceneRequest) return alert("키 또는 씬 요청이 없습니다.");

            // [2025-10-19] 버튼 비활성화
            generateBtn.disabled = true;
            generateBtn.textContent = "생성 중 (3단계)...";
            
            try {
                // [API 분리] /api/generate_scene 호출
                const res = await fetch('/api/generate_scene', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'x-my-secret-key': secretKey},
                    body: JSON.stringify({ sceneRequest, worldviewDatabase })
                });
                if (!res.ok) throw new Error(await res.text());
                const data = await res.json();
                
                // (블록 에디터에 결과 추가)
                data.blocks.forEach(line => {
                    const p = document.createElement('p');
                    p.textContent = line || ' ';
                    document.getElementById('novel-blocks').appendChild(p);
                });
                sceneResultEl.textContent = JSON.stringify(data.instructions, null, 2);

            } catch (e) {
                sceneResultEl.textContent = `오류: ${e.message}`;
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = "✨ 씬 생성하기 (3단계)";
            }
        });

        // --- [편의 기능] Simple Proxy 호출 ---
        const proxyBtn = document.getElementById('proxyButton');
        const proxyResultEl = document.getElementById('proxyResult');
        
        proxyBtn.addEventListener('click', async () => {
            const prompt = document.getElementById('proxyPrompt').value;
            if (!secretKey || !prompt) return alert("키 또는 프롬프트가 없습니다.");

            proxyBtn.disabled = true;

            try {
                // [API 분리] /api/simple_proxy 호출
                const res = await fetch('/api/simple_proxy', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'x-my-secret-key': secretKey},
                    body: JSON.stringify({ model: 'gemini-2.5-flash', prompt })
                });
                if (!res.ok) throw new Error(await res.text());
                const data = await res.json();
                proxyResultEl.textContent = data.text;
            } catch (e) {
                proxyResultEl.textContent = `오류: ${e.message}`;
            } finally {
                proxyBtn.disabled = false;
            }
        });

    </script>
</body>
</html>
